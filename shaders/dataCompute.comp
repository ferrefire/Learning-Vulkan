#version 450

#extension GL_ARB_shading_language_include : require

struct ComputeData
{
	float viewHeight;
    float frustumIntersect;
    float frustumIntersectSecond;
    float frustumIntersectAverage;
};

layout(std430, set = 1, binding = 0) buffer Data
{
	ComputeData computeData;
};

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#include "variables.glsl"
#include "heightmap.glsl"

#define CORNER_COUNT 13
#define ITERATIONS 25

void main()
{
    computeData.viewHeight = SampleDynamic(variables.viewPosition.xz);

    //float corner1Intersect = 1000;
    //float corner2Intersect = 1000;
    //float corner3Intersect = 1000;
    //float corner4Intersect = 1000;
    //float corner12Intersect = 1000;
    //float corner34Intersect = 1000;
    //float corner13Intersect = 1000;
    //float corner24Intersect = 1000;

    vec3 frustumCorner12 = (variables.frustumCorner1 + variables.frustumCorner2) * 0.5;
    vec3 frustumCorner13 = (variables.frustumCorner1 + variables.frustumCorner3) * 0.5;
    vec3 frustumCorner34 = (variables.frustumCorner3 + variables.frustumCorner4) * 0.5;
    vec3 frustumCorner24 = (variables.frustumCorner2 + variables.frustumCorner4) * 0.5;
    vec3 frustumCorner1234 = (variables.frustumCorner1 + variables.frustumCorner2 + variables.frustumCorner3 + variables.frustumCorner4) * 0.25;
    vec3 frustumCornerCTR = (frustumCorner1234 + variables.frustumCorner1) * 0.5;
    vec3 frustumCornerCTL = (frustumCorner1234 + variables.frustumCorner2) * 0.5;
    vec3 frustumCornerCBR = (frustumCorner1234 + variables.frustumCorner3) * 0.5;
    vec3 frustumCornerCBL = (frustumCorner1234 + variables.frustumCorner4) * 0.5;

    int corner = 0;
    vec3 corners[CORNER_COUNT];
    corners[corner++] = variables.frustumCorner1;
    corners[corner++] = variables.frustumCorner2;
    corners[corner++] = variables.frustumCorner3;
    corners[corner++] = variables.frustumCorner4;
    if (CORNER_COUNT >= 9)
    {
        corners[corner++] = frustumCorner12;
        corners[corner++] = frustumCorner13;
        corners[corner++] = frustumCorner34;
        corners[corner++] = frustumCorner24;
        corners[corner++] = frustumCorner1234;

        if (CORNER_COUNT >= 13)
        {
            corners[corner++] = frustumCornerCTR;
            corners[corner++] = frustumCornerCTL;
            corners[corner++] = frustumCornerCBR;
            corners[corner++] = frustumCornerCBL;
        }
    }

    float intersects[CORNER_COUNT];
    for (int i = 0; i < CORNER_COUNT; i++)
    {
        intersects[i] = 1000;
    }

    for (int i = 0; i < ITERATIONS; i++)
    {
        //float iter = float(i) / ITERATIONS;
        float iter = pow(float(i) / ITERATIONS, 2);

        //if (corner1Intersect >= 1000)
        //{
        //    vec3 intersectPos = mix(variables.viewPosition, variables.frustumCorner1, iter);
        //    float intersectHeight = SampleDynamic(intersectPos.xz) * 5000.0;
        //    if (intersectHeight >= intersectPos.y) corner1Intersect = iter * 1000.0;
        //}
        //if (corner2Intersect >= 1000)
        //{
        //    vec3 intersectPos = mix(variables.viewPosition, variables.frustumCorner2, iter);
        //    float intersectHeight = SampleDynamic(intersectPos.xz) * 5000.0;
        //    if (intersectHeight >= intersectPos.y) corner2Intersect = iter * 1000.0;
        //}
        //if (corner3Intersect >= 1000)
        //{
        //    vec3 intersectPos = mix(variables.viewPosition, variables.frustumCorner3, iter);
        //    float intersectHeight = SampleDynamic(intersectPos.xz) * 5000.0;
        //    if (intersectHeight >= intersectPos.y) corner3Intersect = iter * 1000.0;
        //}
        //if (corner4Intersect >= 1000)
        //{
        //    vec3 intersectPos = mix(variables.viewPosition, variables.frustumCorner4, iter);
        //    float intersectHeight = SampleDynamic(intersectPos.xz) * 5000.0;
        //    if (intersectHeight >= intersectPos.y) corner4Intersect = iter * 1000.0;
        //}
        //if (corner1Intersect < 1000 && corner2Intersect < 1000 && corner3Intersect < 1000 && corner4Intersect < 1000) break;

        int exitLoop = CORNER_COUNT;
        for (int j = 0; j < CORNER_COUNT; j++)
        {
            if (intersects[j] >= 1000)
            {
                vec3 intersectPos = mix(variables.viewPosition, corners[j], iter);
                float intersectHeight = SampleDynamic(intersectPos.xz) * 5000.0;
                if (intersectHeight >= intersectPos.y) intersects[j] = iter * 1000.0;
            }
            else
            {
                exitLoop -= 1;
            }
        }

        if (exitLoop <= 0) break;
    }

    //float furthestIntersect = max(max(max(corner1Intersect, corner2Intersect), corner3Intersect), corner4Intersect);
    //float furthestIntersect = max(corner1Intersect, corner2Intersect);

    float furthestIntersect = -1;
    float secondFurthestIntersect = -1;
    float averageIntersect = 0;
    for (int i = 0; i < CORNER_COUNT; i++)
    {
        if (intersects[i] > furthestIntersect)
        {
            secondFurthestIntersect = furthestIntersect;
            furthestIntersect = intersects[i];
        }
        else if (intersects[i] > secondFurthestIntersect)
        {
            secondFurthestIntersect = intersects[i];
        }
        averageIntersect += intersects[i];
    }

    computeData.frustumIntersect = furthestIntersect;
    computeData.frustumIntersectSecond = secondFurthestIntersect;
    computeData.frustumIntersectAverage = averageIntersect / CORNER_COUNT;

    //computeData.frustumIntersectAverage = (corner1Intersect + corner2Intersect + corner3Intersect + corner4Intersect) * 0.25;

    //for (int i = 0; i < 1; i++)
    //{
    //    float c1Mult = 1.0 - pow(abs(corner1Intersect - computeData.frustumIntersectAverage) * 0.001, 2);
    //    float c2Mult = 1.0 - pow(abs(corner2Intersect - computeData.frustumIntersectAverage) * 0.001, 2);
    //    float c3Mult = 1.0 - pow(abs(corner3Intersect - computeData.frustumIntersectAverage) * 0.001, 2);
    //    float c4Mult = 1.0 - pow(abs(corner4Intersect - computeData.frustumIntersectAverage) * 0.001, 2);
    //    float totalMult = c1Mult + c2Mult + c3Mult + c4Mult;
    //    computeData.frustumIntersectAverage = (corner1Intersect * c1Mult + corner2Intersect * c2Mult + corner3Intersect * c3Mult + corner4Intersect * c4Mult) / totalMult;
    //}
}