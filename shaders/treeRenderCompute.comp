#version 450

#extension GL_ARB_shading_language_include : require

struct TreeData
{
	uint posxz;
	uint posyroty;
	uint scaxcoly;
};

struct TreeRenderData
{
	uint posxz;
	uint posyroty;
	uint scaxcoly;
};

layout(std430, set = 1, binding = 0) buffer DataBuffer
{
	TreeData data[];
};

layout(std430, set = 1, binding = 1) buffer RenderBuffer
{
	TreeRenderData renderData[];
};

layout(std430, set = 1, binding = 2) buffer CountBuffer
{
    uint renderCount;
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const int treeBase = 2048;
const int treeRenderBase = 16;
const float spacing = 50;
const float spacingMult = 0.02;

#include "variables.glsl"
#include "functions.glsl"
#include "heightmap.glsl"

void main()
{
	if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0)
	{
		atomicExchange(renderCount, 0);
	}

	vec2 flooredViewPosition = vec2(0);
	flooredViewPosition.x = floor((variables.viewPosition.x) * spacingMult);
	flooredViewPosition.y = floor((variables.viewPosition.z) * spacingMult);

	int ix = int(gl_GlobalInvocationID.x) - int(treeRenderBase * 0.5);
	int iz = int(gl_GlobalInvocationID.y) - int(treeRenderBase * 0.5);

	ix += int(flooredViewPosition.x);
	iz += int(flooredViewPosition.y);

	vec2 worldOffset = vec2(ix, iz);

	ix += int(floor((variables.terrainOffset.x) * spacingMult));
	iz += int(floor((variables.terrainOffset.y) * spacingMult));

	vec2 dataIndexVec = vec2(treeBase * 0.5) + vec2(ix, iz);

	if (dataIndexVec.x < 0 || dataIndexVec.x > treeBase || dataIndexVec.y < 0 || dataIndexVec.y > treeBase) return ;

	uint dataIndex = uint(floor(dataIndexVec.x * treeBase + dataIndexVec.y));

	vec3 offset = vec3(0);
	offset.xz = unpackHalf2x16(data[dataIndex].posxz);
	vec2 yy = unpackHalf2x16(data[dataIndex].posyroty);
	offset.y = yy.x;
	float rotation = yy.y;
	//vec2 xx = unpackHalf2x16(data[gl_InstanceIndex].scaxcoly);
	//scale = xx.x;
	//color = xx.y;

	float x = worldOffset.x * spacing + offset.x;
	float z = worldOffset.y * spacing + offset.z;
	float y = SampleDynamic(vec2(x, z)) * 5000 - 1;
	vec3 worldPosition = vec3(x, y, z);

	//ix += int(flooredViewPosition.x + treeBase * 0.5);
	//iz += int(flooredViewPosition.y + treeBase * 0.5);

	//vec3 position = vec3(0);
	//vec3 normal = SampleNormalDynamic(position.xz, 1.0);

	float scale = 1.0;
	float color = 1.0;
	//float rotation = 0.0;

	uint index = atomicAdd(renderCount, 1);

	renderData[index].posxz = packHalf2x16(worldPosition.xz - variables.viewPosition.xz);
	renderData[index].posyroty = packHalf2x16(vec2(worldPosition.y - variables.viewPosition.y, rotation));
	renderData[index].scaxcoly = packHalf2x16(vec2(scale, color));
}